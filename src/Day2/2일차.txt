1. 연산자
 1)증감연산자 : 최종적으로 A만큼 증가/A만큼 감소한다.
  -전위형 : ++A , --A => 증감후 동작
  -후위형 : A++ , A-- => 동작후 증감
 2)부호연산자 : - 부호를 반대로
 3)산술연산자 : + - * /
   ex) 1 + 2 = 3     3.1 * 3 = > 9.3
        1.2 + 3 = 4.2    1 / 2 = 0
        3 * 3 = 9    1.0 /2 = 0.5
   정수 연산자 정수 = 정수 -- 연산자를 통해 연산이 되면서 자동적으로 int변환되어 계산된다.
   byte c = (byte)(a + b); 전체적으로 바꿔주어야하기 때문에 a + b는 묶어야한다.
   정수 연산자 실수 = 실수
   실수 연산자 정수 = 실수
   실수 연산자 실수 = 실수
   -정수/정수는 결과가 정수이어서 소수점이 사라져 원하는 결과가 나오지 않을 수 있다.
 4)나머지 연산자 : A % B = A 를 B로 나누었을 때 나머지
  ex) 5 % 3 = 2
  -%의 결과는 0~B-1사이의 값이다.
  -%는 주로 배수, 약수를 구할 때 사용
 5)대입 연산자 : =
   -오른쪽에 있는 값을 왼쪽에 저장
   -왼쪽에는 상수가 없다.
   -왼쪽에는 연산자가 올 수 없다.
   -비교 연산자 ==와 많이 혼동(조건문)
   x = 2; : o
   2 = x; : x
 6)비교 연산자 : < , > , <= , >= , == , !=
   -비교 연산자는 결과가 참 또는 거짓으로 나온다.
   -결과가 참 또는 거짓만 나오는 식을 조건식이라 한다.
   -비교 연산자는 일반 자료형에서만 정상 동작을 한다.
 7)논리 연산자 : && , || , !
   -&& : ~하고 , 둘다 참인 경우만 참, 나머지는 거짓 OO = O OX = X XO = X XX = X
   -|| : ~하거나 , 둘다 거짓인 경우만 거짓, 나머지는 참 OO = O OX = O XO = O XX = X
   -! : 반대 !O = X !X = O
   -논리 연산자는 조건식 중 하나이다.
   ex) 90 <= score <= 100 ====> score >= 90 && score <= 100
                                          스코어는 90보다 크고 100보다 작다
 8)비트 연산자
   -비트 논리 연산자 : & AND , | OR , ^ XOR , ~
   ex) int num1 = 12, num2 = 10;
        12 : 00000000 00000000 00000000 00001100
        10 : 00000000 00000000 00000000 00001010
        num1 & num2 : 00000000 00000000 00000000 00001000
        num1 | num2  : 00000000 00000000 00000000 00001110
        num1 ^ num2 : 00000000 00000000 00000000 00000110
        ~num1  : 11111111 11111111 11111111 11110011
       (2의 보수) : 00000000 00000000 00000000 00001100
  	  		       	  	         +1 =-13
   -비트 쉬프트 연산자 : << , >>
    << : 비트를 왼쪽으로 이동
    >> : 비트를 오른쪽으로 이동
    -비트 쉬프트 연산자는 비트를 이동시킨 후에 남은 자리는 부호비트로 채운다.
    ex) 10 : 00001010
         10 >> 1 : 00001010 -> 0000101 -> 0+0000101 => 00000101
         10 >> 2 : 00001010 -> 000010 -> 00+000010 => 00000010
         10 >> 3 : 00001010 -> 00001 -> 000+00001 => 00000001
         10 << 1 : 00001010 -> 0001010 -> 0001010+0 => 00010100
         10 << 2 : 00001010 -> 001010 -> 001010+00 => 00101000
         10 << 3 : 00001010 -> 01010 -> 01010+000 => 01010000

 9)복합 대입 연산자
  -A = A 연산자 B; == A 연산자= B;
   ex) A = A + B; == A += B;

 10)조건 연산자(삼항 연산자)
  -(조건식) ? 참 : 거짓; 
  -변수 = (조건식) ? 참 : 거짓; : 조건이 참일 때 변수는 참, 조건이 거짓일 때 변수는 거짓
  ex) int num = 4;
      boolean isEven = (num % 2 ==0) ? true : false;
                   변수 =      (조건식)     ?   참  : 거짓;
 
2.조건문 : ~하면 / ~라면/ ~이면 ~한다
 1)if문 : 모든 조건문은 if문으로 표현 가능하다.
  -if (조건식1) {		if (num가 짝수이다) {
   	실행문1;			num는 짝수라고 출력;
   }else if (조건식2) {	}
   	실행문2;
	    :
	    :
	    :
	    :
	   n-1
   }else {
   	실행문n;
   }
   if문만을 사용할 경우에는 맞는 조건식이 있더라도 모든 조건식을 돌아야한다.
   -조건식1이면 실행문1을 한다. 조건식2이면 실행문2를 한다.·····n-1 모두가 아니면 실행문n을 한다.
   -else는 나머지의 의미로 조건식이 따로 없다.
   -중첩 if문 : if문 안에 실행문으로 if문이 오는 경우
   -if(조건식1) {
    	if(조건식2) {
    		실행문1;
    	}
    }
 2)switch문 : 상황에 따라 switch문으로 표현하면 if문보다 간결하게 표현 가능하다.
  -사용되는 변수의 값이 제한적인 경우(정수, 문자, 문자열)
  -사용되는 식의 결과가 제한적인 경우(실수는 범위가 크기때문에 안됌)
  -switch(변수나 식) {			if(변수나 식 == 값1) {
  	case 값1 :				실행문1;
  		실행문1;			}else if(변수나 식 == 값2) {
  		break;				실행문2;
  	case 값2 :                      ===>	}else {
  		실행문2;				실행문3;
  		break;			}
   	default :
  		실행문3;

3.반복문
 1)규칙성을 가진 작업을 반복적으로 할 때 사용
  -규칙성 찾기 : 초기화, 조건식, 증감연산식
  -반복횟수 : 실행문
  -반복문종료후
  -for, while	do while
  -for문 문법  (실행순서 => 초->조->실->증->조->실->증->·········)
  -for(1.초기화; 2.5.8.조건식; 4.7.증감연산식) {
	3.6.실행문;
   }
    1.초기화 : 조건식이나 실행문에서 사용하는 변수의 값을 초기화하는 곳으로생략할 수 있고, 
	     여러 변수를 통해 초기화 할 수 있다.
    2.조건식 : 반복문이 실행되기 위한 조건으로 참이면 반복문을 계속 실행, 거짓이면 종료
  	     생략이 가능하며 생략하면 무조건 참으로 된다.
    3.실행문
    4.증감연산식 : 조건식에서 사용하는 변수를 증감시켜 반복횟수를 조절한다. 생략 가능하다.
	          반복문에서 반복횟수는 초기화 + 조건식 + 증감연산식이 함께 관여한다.
